# Fikra Platform — Full Audit and Refactoring Plan

فحص شامل وإعادة هيكلة لمنصة فكرة: الواجهة/تجربة المستخدم، الباك-أند (Prisma + Supabase Auth اختياري)، الأمان، الموثوقية، التخزين المؤقت، والنشر، مع تركيز على إدارة الطلبات والمحادثة والمدفوعات.

---

## Architecture Context (Critical)

- **Database:** Prisma + PostgreSQL (DATABASE_URL). لا Supabase كقاعدة تطبيق؛ التفويض في مسارات API عبر lib/requireAuth.ts.
- **Auth:** NextAuth (Credentials) أو Supabase Auth عبر NEXT_PUBLIC_USE_SUPABASE_AUTH.
- **Chat:** REST API + است轮询 من العميل (3 ثوانٍ). لا Supabase Realtime.
- **Payment:** لا webhook لبوابة خارجية؛ app/api/payments/create/route.ts ينشئ دفعة status: 'completed' ويترك الطلب PENDING.

---

## Phase 1: Order Management System (Core Engine)

- **Schema and state machine:** إدخال enum لحالة الطلب ووحدة orderStateMachine (lib/orderStateMachine.ts) لتعريف الانتقالات المسموحة؛ تمرير كل تحديثات الحالة عبر مساعد واحد.
- **Validation (Zod):** تعريف schema صارم لـ formData في schemas/orderFormSchema.ts واستخدامه في API وواجهة إنشاء الطلب.
- **Audit / versioning:** إضافة جدول OrderAuditLog (orderId, userId, action, oldValue/newValue, createdAt)؛ إدراج سجل عند تغيير الحالة وعرض آخر N في واجهة المهندس.
- **Foreign keys and indexes:** المخطط الحالي يحدد الفهارس المطلوبة؛ لا تغيير إلا عند إضافة أعمدة جديدة.

---

## Phase 2: Real-time Chat Module

- **Realtime vs polling:** توثيق أن "الوقت الحقيقي" عبر است轮询 قصير؛ إن لزم وقت حقيقي: Supabase Realtime أو طبقة منفصلة (Pusher, Ably) مع Prisma كمصدر حقيقة.
- **Optimistic UI:** التأكد من التراجع عن الرسالة المتفائلة عند فشل الإرسال (إزالة من الحالة أو وضع علامة فشل) وعرض toast.
- **Security:** الإبقاء على التحكم في الوصول في مسارات API.
- **Attachments:** إن وُجدت مرفقات: استخدام lib/storage.ts مع مسار مخصص، فرض حجم ونوع MIME، تخزين URL فقط في Message.

---

## Phase 3: Payment System Integrity

- **Idempotency:** قبول idempotencyKey اختياري (UUID من العميل) في body إنشاء الدفع؛ تخزينه في جدول PaymentIdempotency؛ عند تكرار المفتاح خلال TTL إرجاع نفس الاستجابة.
- **Order status:** الإبقاء على الدلالة الحالية (الطلب يبقى PENDING؛ "مدفوع" = وجود دفعة مكتملة) أو إدخال حالة صريحة مثل PAID عند دمج بوابة حقيقية.
- **Webhooks (مستقبلاً):** عند دمج مزود دفع: إضافة مسار webhook يتحقق من التوقيع، يستخدم idempotency، يحدّث Payment/Order بعد التحقق، ويرد 200 بسرعة.
- **Failed/cancelled in UI:** التعامل صراحة مع "إلغاء المستخدم" وعرض رسالة واضحة.

---

## Phase 4: Frontend, UX, and UI Consistency

- **User flows:** توحيد حالات التحميل وأخطاء الـ toast وإعادة التوجيه عند عدم المصادقة أو دور خاطئ؛ إضافة حارس دور أو فحص على مستوى layout.
- **Accessibility and responsiveness:** مراجعة عناصر التفاعل (focus، لوحة المفاتيح، aria-labels)، RTL وتكبير الخط، استجابة الجداول/البطاقات.
- **Error boundaries:** لف واجهة المحادثة ونموذج إنشاء الطلب في ErrorBoundary مخصص مع fallback وretry.

---

## Phase 5: Backend (Prisma + Supabase Auth) and Security

- **Supabase usage:** عدم over-fetch؛ الاستمرار في select/include فقط للحقول المطلوبة؛ إن استُخدم Supabase كـ host لـ PostgreSQL ضبط connection pooling و DATABASE_URL.
- **SQL injection and input validation:** الاستمرار في Prisma لجميع الكتابات؛ التحقق من body/query بـ Zod في كل مسار وإرجاع 400 عند مدخل غير صالح.
- **Auth audit:** مراجعة matcher في الـ middleware وضمان عدم تخطي مسارات API محمية؛ التعامل مع انتهاء الجلسة وتجديدها (401 وإعادة توجيه لتسجيل الدخول).

---

## Phase 6: Performance, Caching, and Reliability

- **Caching:** إضافة SWR أو TanStack Query للقوائم وتفاصيل الطلب والرسائل؛ الإبقاء على unstable_cache للباقات والصفحة الرئيسية؛ استخدام cache tags لبطء القوائم حسب المستخدم.
- **Error tracking and logging:** دمج Sentry في الإنتاج (componentDidCatch و handleApiError)؛ تسجيل منظم للإجراءات الحرجة (إنشاء طلب، دفعة، تغيير حالة، إرسال رسالة).
- **Resilience:** ضبط مهلة اتصال Prisma واعتبار إعادة محاولة قصيرة للأخطاء العابرة؛ إن استُخدم Supabase Auth ضمان تعامل العميل مع فشل تجديد الجلسة.
- **Testing:** اختبارات وحدة لانتقالات حالة الطلب، التحقق من إنشاء الطلب (Zod)، وإنشاء الدفع (idempotency عند التطبيق).

---

## Phase 7: Deployment and Configuration

- **Vercel and build:** ضبط المدة القصوى للـ serverless عند الحاجة؛ مراقبة حجم الحزمة وتحميل كسول للمكونات الثقيلة؛ ضبط NODE_ENV والمتغيرات لكل بيئة.
- **Environment and Supabase production:** توحيد .env.example مع الاستخدام الفعلي (PostgreSQL محلي وإنتاج)؛ توثيق النسخ الاحتياطي و Point-in-Time Recovery في Supabase إن وُجد.

---

## Execution Order (Suggested)

1. Phase 1 (Order): schema صارم لـ formData + state machine مشترك + OrderAuditLog اختياري وتوصيله.
2. Phase 2 (Chat): تراجع optimistic عند فشل الإرسال؛ توثيق الاست轮询؛ Error Boundary حول المحادثة.
3. Phase 3 (Payment): مفتاح وجدول idempotency؛ الإبقاء على دلالة "دفعة مكتملة" حتى إضافة بوابة؛ ثم مسار webhook مع توقيع وidempotency.
4. Phase 4 (Frontend): Error boundaries للمحادثة وإنشاء الطلب؛ مراجعة a11y واستجابة؛ توحيد واجهة التحميل/الخطأ.
5. Phase 5 (Security): مراجعة Auth/ middleware؛ التحقق من كل مدخلات API.
6. Phase 6 (Performance): SWR أو TanStack Query للطلبات والمحادثة؛ Sentry وتسجيل منظم؛ إعادة محاولة Prisma اختيارية؛ اختبارات وحدة للطلب والدفع.
7. Phase 7 (Deploy): قائمة env و Vercel؛ توثيق إعدادات Supabase للإنتاج.

---

## File Paths Summary (Key Files)

| Area | Files |
|------|--------|
| Order schema/validation | schemas/orderFormSchema.ts, app/api/orders/create/route.ts, CreateOrderContent.tsx |
| Order state / audit | lib/orderStateMachine.ts, prisma/schema.prisma (OrderAuditLog), مسارات الحالة |
| Chat | صفحات المحادثة (عميل/مهندس): Error Boundary + تراجع optimistic |
| Payment | app/api/payments/create/route.ts (idempotency), جدول idempotency |
| Error boundaries | صفحات المحادثة، صفحة إنشاء الطلب أو غلاف CreateOrderContent |
| Caching / data fetching | SWR أو TanStack Query للقوائم وتفاصيل الطلب والمحادثة |
| Logging / errors | lib/logger.ts, lib/errors.ts, ErrorBoundary — دمج Sentry |
| Config | .env.example, next.config.js, إعدادات Vercel |
